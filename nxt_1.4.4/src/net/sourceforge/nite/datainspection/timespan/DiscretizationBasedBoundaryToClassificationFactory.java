package net.sourceforge.nite.datainspection.timespan;

import net.sourceforge.nite.datainspection.data.Classification;
import net.sourceforge.nite.datainspection.data.Item;
import net.sourceforge.nite.datainspection.impl.BooleanValue;
import net.sourceforge.nite.datainspection.impl.TimespanItem;
import net.sourceforge.nite.util.Pair;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * This class makes classifications from boundary lists by discretizing the timeline into items
 * and using True or False as Value depending on whether the boundarylist contained a boundary in 
 * that segment. Used by BoundaryBasedInspection2
 *
 * This class works in two step:
 * <br>1) make a list of items ('time spans') that are to be used for all annotators
 * <br>2) given the list of Items, and a boundarylist, generate a Classification.
 *
 * See design on paper for documentation
 */
public class DiscretizationBasedBoundaryToClassificationFactory {
    
    /** Make a list of items ('time spans') that are to be used for all annotators by
    discretizing the timeline from 0 to endtime (usually obtained from getCorpusEndTime)
    in segments of 'th' duration. */
    public static List generateDiscretizedItems(double endtime, double th) {
        ArrayList result = new ArrayList();
        double s = 0;
        while (s < endtime) {
            result.add(new TimespanItem(s, s+th));
            s+=th;
        }
        return result;
    }
    
    
    /** Given the list of Items generated by generateDiscretizedItems, and a boundarylist, 
    generate a Classification. Values are True if the boundarylist contains a boundary within the 
    TimespanItem. */
    public static Classification makeClassificationsFromBoundaryList(
                    List boundaryList,
                    List items
                   ) {
            Classification c = new Classification("");
            //prepare to investigate the (sorted) boundaries
            Iterator boundaryIt = boundaryList.iterator();
            Boundary nextBoundary = null;
            if (boundaryIt.hasNext()) {
                nextBoundary = (Boundary)boundaryIt.next();
            }
            //for each item in the list, generate a value, and extend the classification.
            for (int i = 0; i < items.size(); i++) {
                //get next item
                TimespanItem item = (TimespanItem)items.get(i);
                BooleanValue val = new BooleanValue(false); //by default, expect there to be no boundary here
                //if nextboundary not null, and nextboundary within item, set value to true and advance to next boundary AFTER this item
                if ( (nextBoundary != null) && (nextBoundary.time >= item.start) && (nextBoundary.time < item.end) ) {
                    val = new BooleanValue(true);
                    while (nextBoundary.time < item.end) {
                        if (boundaryIt.hasNext()) {
                            nextBoundary = (Boundary)boundaryIt.next();
                        } else {
                            nextBoundary = null; //reached end of boundary list
                            break;
                        }
                    }
                }
                c.add(item,val);
            }
            return c;
    }

}