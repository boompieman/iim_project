/* NXT (NITE XML Toolkit) Search
 * NITE (Natural Interactivity Tools Engineering) project
 * IMS, University of Stuttgart
 * Holger Voormann
 */
package net.sourceforge.nite.search;

import net.sourceforge.nite.search.rewriter.*;
import java.io.StringReader;
import java.util.List;
import java.util.Vector;
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.Iterator;
//import net.sourceforge.nite.nomread.*;

/**
 * Engine is the main component of NXT (NITE XML Toolkit) Search.
 * The most important methode is {@link
 * #search(net.sourceforge.nite.search.SearchableCorpus, java.lang.String)}
 * which could be {@link #interrupt()}. The result, a List of
 * Lists, could be flatten (cf. {@link #flattenListOfResults(java.util.List)})
 * or converted into XML (cf. {@link #resultToXML(java.util.List)}).
 * For debugging the methodes {@link
 * #showParseTree(java.lang.String, java.lang.String)} and {@link
 * #showDNF(java.lang.String)} may be useful.
 */
public class Engine implements Interruptable, Progressable {
    private final static int 
	ITERATOR_EACH_ELEMENT         = 0,
	ITERATOR_TYPED_ELEMENTS       = 1,
	ITERATOR_ELEMENTS_DOMINATED   = 2,
	ITERATOR_ELEMENTS_DOMINATING  = 3,
	ITERATOR_ELEMENTS_POINTED     = 4,
	ITERATOR_ELEMENTS_OF_SUBGRAPH = 5;


    private static String XML_HEAD =
	"<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?>\n";
    private static final String NITE_NAMESPACE_NAME = "xmlns:nite";
    private static final String NITE_NAMESPACE = "http://nite.sourceforge.net/";
    private boolean interrupted = false;
    private Vector progressListeners = new Vector();

    private QueryRewriter rewriter;



    /**
     * Creates a new search engine.
     */
    public Engine() {}

    /**
     * Stops a running search task started by search(...).
     */
    public void interrupt() { interrupted = true; }

    /**
     * Return true if {@link #interrupt()} is executed after search(...).
     * @return true if {@link #interrupt()} is executed after search(...).
     */
    public boolean isInterrupted() { return interrupted; }

    /**
     * Finds all sets of elements refering to variables satisfing the query.
     * For preprocessing the given query string will be parsed by the
     * {@link Parser} generated by
     * <a href="http://www.webgain.com/products/java_cc/">JavaCC</a>.
     * Afterward all possible sets of elements refering to variables are generated
     * and tested against the query.<br>
     * The return is a list of lists. The first list contains the variable names.
     * The other lists are sets of elements, ordered like the variable names.<br>
     * E.g. "($a)($b):..." may return something like <b>{</b> {"$a", "$b"},
     * {e1 ,e2}, {e1 ,e3}, {e2 ,e4}, ... <b>}</b> where eX are
     * {@link net.sourceforge.nite.nomread.NOMElement}s. The complex query
     * "($a)($b):... :: ($c): ..." may return something like<br>
     * &nbsp; <b>{</b> {"$a", "$b"},<br>
     * &nbsp; &nbsp; {e1, e2, <b>{</b>{"$c"}, {e5}, {e6}, ... <b>}</b>},<br>
     * &nbsp; &nbsp; {e3, e4, <b>{</b>{"$c"}, {e7}, {e7}, ... <b>}</b>}, ... <b>}
     * </b>.
     * @param corpus the corpus in which will be searched
     * @param query the query string
     * @return all sets of elements refering to variables satisfing the query
     * @throws Throwable lexical or syntax error of parsing the query or running
     * out of memory
     */
    public List search(SearchableCorpus corpus, String query) throws Throwable {
	return search(corpus, query, -1);
    }

    /**
     * Finds maximum n sets of elements refering to variables satisfing the query.
     * For preprocessing the given query string will be parsed by the
     * {@link Parser} generated by
     * <a href="http://www.webgain.com/products/java_cc/">JavaCC</a>.
     * Afterward possible sets of elements refering to variables are generated
     * and tested against the query until maximum n sets are found.<br>
     * The return is a list of lists. The first list contains the variable names.
     * The other lists are sets of elements, ordered like the variable names.<br>
     * E.g. "($a)($b):..." may return something like <b>{</b> {"$a", "$b"},
     * {e1 ,e2}, {e1 ,e3}, {e2 ,e4}, ... <b>}</b> where eX are
     * {@link net.sourceforge.nite.nomread.NOMElement}s. The complex query
     * "($a)($b):... :: ($c): ..." may return something like<br>
     * &nbsp; <b>{</b> {"$a", "$b"},<br>
     * &nbsp; &nbsp; {e1, e2, <b>{</b>{"$c"}, {e5}, {e6}, ... <b>}</b>},<br>
     * &nbsp; &nbsp; {e3, e4, <b>{</b>{"$c"}, {e7}, {e7}, ... <b>}</b>}, ... <b>}
     * </b>.
     * @param corpus the corpus in which will be searched
     * @param query the query string
     * @param max the limit of returning results or if -1 unlimited
     * @return maximum n sets of elements refering to variables satisfing the query
     * @throws Throwable lexical or syntax error of parsing the query or running
     * out of memory
     */
    public List search(SearchableCorpus corpus, String query, long max)
	throws Throwable
    {
	NodeQuery n = ( new Parser( new StringReader(query+"\n") ) ).Query();
        if (corpus.isQueryRewriting()) {
            rewriter = corpus.getQueryRewriter();
	    if (rewriter!=null) { n = rewriter.rewrite(n); }
        }
	List result = new ArrayList();
	for(int i=0; i<n.jjtGetNumChildren(); i++) {
	    simpleSearch(corpus, result, (NodeSimpleQuery)n.jjtGetChild(i), max);
	    if( result.isEmpty() ) { break; }
	}
        if (corpus.isQueryRewriting()) {
	    result = rewriter.rewriteResult(result);
	}
	return result;
    }

    /** a complex query (like: ($a): ... :: ($b): ... ) is split into simple
     *  queries (like: ($a): ... ), evaluated from left to right. */
    private void simpleSearch( SearchableCorpus corpus,
			       List             inputResult,
			       NodeSimpleQuery  simpleQuery,
			       long             max)
	throws Throwable
    {
	//interface Interruptable: start running
	interrupted = false;

	//variable names: input, free, quantified
	List varNamesInput     = new ArrayList();   //names of input variables
	List varNamesFree      = new ArrayList();   //names of non input variables
	//without quantifier
	List varNamesQuantified = new ArrayList();  //names of input variables
	//with a quantifier
	List typeConditions     = new ArrayList();  //variable type definitions
	for( Iterator i = simpleQuery.getVarNames().iterator(); i.hasNext(); ){
	    String variableName = (String)i.next();
	    //collect all names of variables with quantifier ...
	    if(  simpleQuery.isExists(variableName)
		 || simpleQuery.isForAll(variableName) ){
		varNamesQuantified.add(variableName);
		//... and free variable (= not input or quantified)
	    } else {
		varNamesFree.add(variableName);
	    }
	    //collect all variable type definitions
	    if( !simpleQuery.getTypes(variableName).isEmpty() ){
		typeConditions.add( new NodeCondition( variableName,
						       simpleQuery.getTypes(variableName) ) );
	    }
	}

	//input: current input lists and the position to add
	List inputLists         = new ArrayList();      //path from input result
	//list to addHere
	List varNamesInputLists = new ArrayList();      //list of input variable
	//names lists
	List addHere            = inputResult;          //new results must be added
	//at the end of this list

	//disjunctive normal form (= sop, sum of products)
	NodeCondition[][] dnf;
	//possible iterators extracted from query
	List possibleIterators3 = new ArrayList();

	//1.
	//getting dnf and all possible iterators from the (simple) query
	{
	    if( simpleQuery.jjtGetNumChildren() == 0 ){
		if( typeConditions.isEmpty() ){
		    dnf = new NodeCondition[0][0];
		} else {
		    dnf = new NodeCondition[1][typeConditions.size()];
		    for( int i=0; i<dnf[0].length; i++ ){
			dnf[0][i] = (NodeCondition)typeConditions.get(i);
		    }
		}
	    } else {
		List dnfList = ((NodeLogical)simpleQuery.jjtGetChild(0)).dnf;
		dnf = new NodeCondition[dnfList.size()][];
		for( int i=0; i<dnf.length; i++ ){
		    List minterm = (List)dnfList.get(i);
		    dnf[i] = new NodeCondition[ minterm.size() + typeConditions.size() ];
		    for( int j=0; j<minterm.size(); j++ ){
			//dnf term
			dnf[i][j] = (NodeCondition)minterm.get(j);

			//possible iterators:
			if( dnf[i][j].isNegated ){  //skip

			    //- dominated by, dominating
			} else if( dnf[i][j].getType() == NodeCondition.DOMINANCE ){
			    possibleIterators3.add(
						   new PossibleIterator( ITERATOR_ELEMENTS_DOMINATED,
									 dnf[i][j].getBVar(),
									 dnf[i][j].getAVar(),
									 i ) );
			    possibleIterators3.add(
						   new PossibleIterator( ITERATOR_ELEMENTS_DOMINATING,
									 dnf[i][j].getAVar(),
									 dnf[i][j].getBVar(),
									 i ) );
			} else if( dnf[i][j].getType() == NodeCondition.DOMINANCE_WITH_DISTANCE ){
			    possibleIterators3.add(
						   ( dnf[i][j].getDistance() < 0 ) ?
						   new PossibleIterator( ITERATOR_ELEMENTS_DOMINATED,
									 dnf[i][j].getAVar(),
									 dnf[i][j].getBVar(),
									 i ) :
						   new PossibleIterator( ITERATOR_ELEMENTS_DOMINATED,
									 dnf[i][j].getBVar(),
									 dnf[i][j].getAVar(),
									 i ) );
			    possibleIterators3.add(
						   ( dnf[i][j].getDistance() < 0 ) ?
						   new PossibleIterator( ITERATOR_ELEMENTS_DOMINATING,
									 dnf[i][j].getBVar(),
									 dnf[i][j].getAVar(),
									 i ) :
						   new PossibleIterator( ITERATOR_ELEMENTS_DOMINATING,
									 dnf[i][j].getAVar(),
									 dnf[i][j].getBVar(),
									 i ) );

			    //- pointing
			} else if(  ( dnf[i][j].getType() == NodeCondition.POINTER_WITH_ROLE )
				    || ( dnf[i][j].getType() == NodeCondition.POINTER ) ){
			    possibleIterators3.add(
						   new PossibleIterator( ITERATOR_ELEMENTS_POINTED,
									 dnf[i][j].getBVar(),
									 dnf[i][j].getAVar(),
									 i ) );
			    //- subgraph
			} else if(  ( dnf[i][j].getType() == NodeCondition.SUBDOM_WITH_ROLE )
				    || ( dnf[i][j].getType() == NodeCondition.SUBDOM ) ){
			    possibleIterators3.add(
						   new PossibleIterator( ITERATOR_ELEMENTS_OF_SUBGRAPH,
									 dnf[i][j].getBVar(),
									 dnf[i][j].getAVar(),
									 i ) );
			}
		    }
		    //
		    for( int j=minterm.size(); j<dnf[i].length; j++ ){
			dnf[i][j] = (NodeCondition)typeConditions.get( j - minterm.size() );
		    }
		}
	    }
	}


	//2.
	//find position for adding new results (= addHere) and fill inputVarNames
	while( true ){
	    try {
		//break if there is no such list:
		List varNames    = (List)addHere.get(0);
		List firstResult = (List)addHere.get(1);
		varNamesInputLists.add(varNames);
		varNamesInput.addAll(varNames);
		inputLists.add(addHere);
		if( firstResult.size() > varNames.size() ){
		    addHere = (List)firstResult.get( varNames.size() );
		} else {
		    // position to add found
		    // -> add empty list (for adding new result) and stop
		    addHere = new ArrayList();
		    firstResult.add(addHere);
		    break;
		}
	    } catch( Exception e ){ break; }
	}

	// inputIndex: current input match, initialed with "1"s
	int  numberInputVars = varNamesInput.size();  //number of all input variables
	int[] inputIndex = new int[ varNamesInputLists.size() ];
	for( int i=0; i<inputIndex.length; i++ ) { inputIndex[i]=1; }


	//3.
	//discard iterators not supported by all minterms
	//and add variable types iterators
	{
	    List notDiscardedIterators = new ArrayList();
	    for( Iterator i = possibleIterators3.iterator(); i.hasNext(); ){
		PossibleIterator currentIterator = (PossibleIterator)i.next();
		boolean supportedByAllMinterms = false;

		//iterator must be supported of every minterm,
		//that means: there must be an equale iterator for every minterm
		for( int j=0; j<dnf.length; j++ ){
		    supportedByAllMinterms = false;
		    for( Iterator k = possibleIterators3.iterator(); k.hasNext(); ){
			PossibleIterator iterator = (PossibleIterator)k.next();
			if(  currentIterator.equals(iterator)
			     && (iterator.mintermNr == j) ){
			    supportedByAllMinterms = true;
			    break;
			}
		    }
		    if( !supportedByAllMinterms ) break;
		}
		if(  supportedByAllMinterms
		     && !notDiscardedIterators.contains(currentIterator)
		     //basic variable != needed variable (i.e. $x^$x -> discard iterator)
		     && !currentIterator.neededVariable.equals(currentIterator.variable) ){
		    notDiscardedIterators.add(currentIterator);
		}
	    }
	    possibleIterators3 = notDiscardedIterators;
	    //add variable types iterators:
	    //a) for free variables
	    for( Iterator i = varNamesFree.iterator(); i.hasNext(); ){
		String name = (String)i.next();
		if( !simpleQuery.getTypes(name).isEmpty() ){
		    possibleIterators3.add( new PossibleIterator( ITERATOR_TYPED_ELEMENTS,
								  name,
								  "",
								  0 ) );
		}
	    }
	    //b) for quantified variables
	    for( Iterator i = varNamesQuantified.iterator(); i.hasNext(); ){
		String name = (String)i.next();
		if( !simpleQuery.getTypes(name).isEmpty() ){
		    possibleIterators3.add( new PossibleIterator( ITERATOR_TYPED_ELEMENTS,
								  name,
								  "",
								  0 ) );
		}
	    }
	}
	//for(int i=0; i<possibleIterators3.size(); i++){
	//  PossibleIterator x = (PossibleIterator)possibleIterators3.get(i);
	//  System.out.println("   > "+x.type+" "+x.variable+" "+x.neededVariable+" ("+x.mintermNr+")");
	//}


	//4.
	//find best order of free variables to use fastest iterators
	List bestOrder = varNamesFree;  //best order set to default
	{
	    //estimate search space for all permutation of variable orders
	    double smallestSearchSpace = 1;             //1 means 100%
	    for( Iterator i = new ListPermuteIterator(varNamesFree); i.hasNext(); ){
		List currentOrder = (List)i.next();
		double searchSpace = 1;
		//for every variable ...
		for( int j=0; j<currentOrder.size(); j++ ){
		    double bestRating = 1;
		    //... find best rated iterator
		    for( Iterator k = possibleIterators3.iterator(); k.hasNext(); ){
			PossibleIterator iterator = (PossibleIterator)k.next();
			if(  currentOrder.get(j).equals(iterator.variable)
			     // ($a)::($a) ?
			     && (  varNamesInput.contains(iterator.neededVariable)
				   || ( currentOrder.indexOf(iterator.neededVariable) < j )
				   || iterator.neededVariable.equals("") )
			     //                 && ( currentOrder.indexOf(iterator.neededVariable) < j )
			     && ( iterator.getRating() < bestRating ) ){
			    bestRating = iterator.getRating();
			}
		    }
		    searchSpace = searchSpace * bestRating;
		}
		//Have founded variable order with smaller search space?
		if( searchSpace < smallestSearchSpace ){
		    smallestSearchSpace = searchSpace;
		    bestOrder = currentOrder;
		}
	    }
	}
	//System.out.println("Best Order: "+bestOrder);


	//5.
	//create table: varName[] - varIsExists[]
	int       varQuantifierIndex = varNamesInput.size() + bestOrder.size();
	String[]  varName            = new String[   varQuantifierIndex
						     + varNamesQuantified.size() ];
	boolean[] varIsExists        = new boolean[ varName.length ];
	List[]    varTypes           = new List[ varName.length ];
	//references of the originale variable index to restore primary order
	int[]     resortIndex        = new int[ varName.length ];
	for( int i=0; i < varNamesFree.size(); i++ ){
	    resortIndex[i+numberInputVars] = bestOrder.indexOf( varNamesFree.get(i) )
		+ numberInputVars;
	}
	varNamesFree = bestOrder;
	//fill tabel
	{
	    int index = 0;
	    //first: input variables ...
	    for( Iterator i = varNamesInput.iterator(); i.hasNext(); ){
		varName[index] = (String)i.next();
		varIsExists[index] = false;
		index++;
	    }
	    //... then: free variables ...
	    for( Iterator i = varNamesFree.iterator(); i.hasNext(); ){
		varName[index] = (String)i.next();
		varIsExists[index] = false;
		index++;
	    }
	    //... at last: variables with quantifier
	    for( Iterator i = varNamesQuantified.iterator(); i.hasNext(); ){
		varName[index] = (String)i.next();
		varIsExists[index] = simpleQuery.isExists( varName[index] );
		index++;
	    }
	    //fill var types array for element type iterators
	    for( int i=0; i<varName.length; i++ ){
		varTypes[i]= simpleQuery.getTypes(varName[i]);
	    }
	}


	//6.
	//for every non input variable select fastest iterator
	int[] iteratorType = new int[ varName.length ];
	int[] iteratorBasicElement = new int[ varName.length ];
	{
	    List knownVariables = varNamesInput;
	    knownVariables.add("");
	    //for every non input variable (from left to right)...
	    for( int i=numberInputVars; i<varName.length; i++ ){
		double smallestSearchSpace = 1.0;
		iteratorType[i] = ITERATOR_EACH_ELEMENT;
		//... find the fastest iterator (= smallest search space)
		for( Iterator j = possibleIterators3.iterator(); j.hasNext(); ){
		    PossibleIterator currentIterator = (PossibleIterator)j.next();
		    if(  currentIterator.variable.equals(varName[i])
			 && knownVariables.contains(currentIterator.neededVariable)
			 && ( currentIterator.getRating() < smallestSearchSpace ) ){
			smallestSearchSpace = currentIterator.getRating();
			//set faster iterator
			iteratorType[i] = currentIterator.type;
			//find basic element tuple index
			for( int k=0; k<varName.length; k++ ){
			    if( varName[k].equals(currentIterator.neededVariable) ){
				iteratorBasicElement[i] = k;
				break;
			    }
			}

		    }
		    knownVariables.add(varName[i]);
		}
	    }
	}
	//    System.out.print("Iterator Types [");
	//    for(int i=0; i<iteratorType.length; i++){
	//      System.out.print(" "+iteratorType[i]);
	//      if( iteratorType[i] == ITERATOR_ELEMENTS_DOMINATED ){
	//        System.out.print("("+iteratorBasicElement[i]+")");
	//      }
	//    }
	//    System.out.println(" ]");


	//7.
	//set tuple and initialise input tuple digits
	//setTuple
	for( int i=0; i<dnf.length; i++ ){
	    for( int j=0; j<dnf[i].length; j++ ){
		dnf[i][j].setTuple(varName);
	    }
	}
	//initialise input tuple digits
	//tuple is used like a counter walking through every possible combination:
	//variable -> element
	Object[] tuple     = new Object[ varName.length ]; //
	Iterator[]   iterators = new Iterator[   varName.length ];
	//initialise tuple input digits
	int digit = 0;
	for( int i=0; i<inputLists.size(); i++ ){
	    List x = (List)inputLists.get(i);
	    for( int j=0; j<((List)varNamesInputLists.get(i)).size(); j++ ){
		tuple[digit] = ((List)x.get(1)).get(j);
		digit++;
	    }
	}

	//System.out.println("o");


	//outer search loop
	boolean inputHasNext = true;
	do{  //////////////////////////////////////////////////////////////////////
	    // ______________________begin outer search loop______________________

	    //add variable names as first item
	    List varNamesRet = new ArrayList(varQuantifierIndex-numberInputVars);
	    for( int i=numberInputVars; i<varQuantifierIndex; i++ ){
		varNamesRet.add(varName[resortIndex[i]]);
	    }
	    addHere.add(varNamesRet);

	    //number of matches
	    long i = 0;
	    //Has tuple matched query?
	    boolean matched = false;
	    //first digit number to increment
	    int index = numberInputVars - 1;
	    int indexReset = tuple.length - 1; //
	    //inner search loop
	    innerSearchLoop:
	    while (  !interrupted                 ///////////////////////////////////
		     && ((max < 0) || (i<=max)) ) {  // ____begin inner search loop_____


		//I.
		//tuple++
		//find out which digits must be incremented

		while( index >= numberInputVars ){
		    //a.) not quantifiered variable digit
		    if( index < varQuantifierIndex ){
			try {
			    tuple[index] = iterators[index].next();
			    break;                                         // skip while
			} catch( NoSuchElementException exception1 ){}   // go on while loop

			//b.) "exists" variable digit
		    } else if( varIsExists[index] ){
			if( matched ){  //skip
			} else {
			    try {
				tuple[index] = iterators[index].next();
				break;                                       // skip while
			    } catch( NoSuchElementException exception1 ){} // go on while loop
			}

			//c.) "forall" variable digit
		    } else {
			if( !matched ){ //skip
			} else {
			    try {
				tuple[index] = iterators[index].next();
				break;                                       //skip while
			    } catch(NoSuchElementException exception1) {}  //go on while loop
			}
		    }

		    index--;
		    //Finished inner search loop?
		    if( index < numberInputVars){ break innerSearchLoop; }
		}

		// initiale lower digits (= digits with higher index number)
		initialeLowerDigitsLoop:
		for( int j=(index+1); j<tuple.length; j++ ){
		    switch( iteratorType[j] ){
		    case ITERATOR_TYPED_ELEMENTS:
			iterators[j] = corpus.getElements(varTypes[j]);
			break;
		    case ITERATOR_ELEMENTS_DOMINATED:
			iterators[j] = corpus.getElementsDominatedBy(
								     tuple[ iteratorBasicElement[j] ]);
			break;
		    case ITERATOR_ELEMENTS_DOMINATING:
			iterators[j] = corpus.getElementsDominating(
								    tuple[ iteratorBasicElement[j] ]);
			break;
		    case ITERATOR_ELEMENTS_POINTED:
			iterators[j] = corpus.getElementsPointedBy(
								   tuple[ iteratorBasicElement[j] ]);
			break;
		    case ITERATOR_ELEMENTS_OF_SUBGRAPH:
			iterators[j] = corpus.getElementsOfSubgraph(
								    tuple[ iteratorBasicElement[j] ]);
			break;
		    default:
			iterators[j] = corpus.getElements();

		    }
		    try {
			//initiale digit with new iterator
			tuple[j] = iterators[j].next();
		    } catch( NoSuchElementException e ){
			//new iterator has no elements
			while( (j-1) >= numberInputVars ){
			    //increment next higher digit (= digit with index-1)
			    j--;
			    try{
				tuple[j] = iterators[j].next();
				if( j < index ){ index = j; }
				continue initialeLowerDigitsLoop;
			    } catch( NoSuchElementException e2 ) {
				continue;
			    }
			}
			//no next tuple found
			break innerSearchLoop;
		    }
		}


		//II.
		//match test
		matched = true;
		//test all conditions of the dnf
		for(int j=0; j<dnf.length; j++ ){
		    matched = true;
		    for( int k=0; k<dnf[j].length; k++ ){
			if( !dnf[j][k].ask(tuple, corpus) ) {
			    matched = false;
			    break;
			}
		    }
		    if(matched){ break; }
		}


		//III.
		//add result
		if( matched ){
		    List result = new ArrayList(tuple.length);
		    for( int j=numberInputVars; j<varQuantifierIndex; j++ ) {
			result.add(tuple[resortIndex[j]]);
		    }
		    addHere.add(result);
		    i++;
		}
		//remove multiple forall results
		if(  ( index >= varQuantifierIndex )
		     && !varIsExists[index] ){
		    addHere.remove( addHere.size()-1 );
		}


		//IV.
		//fire progress listeners
		for( Iterator listeners = progressListeners.iterator(); listeners.hasNext(); ){
		    ((ProgressListener)listeners.next()).progressChanged(i);
		}


		//V.
		//reset tuple index
		index = indexReset;


	    }  // _______________________end inner search loop_______________________
	    //////////////////////////////////////////////////////////////////////

	    // next input tuple part
	    inputHasNext = false;
	    for( int j=inputIndex.length-1; j>=0; j-- ) {
		try {
		    List x = (List)inputLists.get(j);

		    // if no new results, kill current input result
		    if ( ((List)((List)x.get(inputIndex[j])).get(
								 ((List)varNamesInputLists.get(j)).size() ) ).size() == 1 ) {
			x.remove(inputIndex[j]);
		    } else {
			// increment digit
			inputIndex[j]++;
		    }
		    x.get(inputIndex[j]);  // -> exists next digit? No: ***

		    // set current input lists
		    for( int k=j+1; k<inputLists.size(); k++ ) {
			x = (List)inputLists.get(k-1);     // the predecessor list
			x = (List)x.get(inputIndex[k-1]);  // current predecessor's result
			x = (List)x.get( x.size()-1 );     // last element of result ...
			inputLists.set(k, x);              // ... is the new list
		    }

		    // set current input digits
		    int currentDigit = numberInputVars-1;
		    for( int k=inputIndex.length-1; k>=j; k-- ) {
			x = (List)inputLists.get(k);
			for( int l=((List)varNamesInputLists.get(k)).size()-1; l>=0; l-- ) {
			    tuple[currentDigit] = ((List)x.get(inputIndex[k])).get(l);
			    currentDigit--;
			}
		    }

		    // insert new list for adding results
		    addHere = new ArrayList();
		    x = (List)inputLists.get( inputLists.size()-1 );
		    ((List)x.get(inputIndex[inputIndex.length-1])).add(addHere);

		    inputHasNext = true;
		    break;

		} catch(IndexOutOfBoundsException e) {
		    inputIndex[j] = 1;    // *** initial digit
		}
	    }

	} while(inputHasNext);  // _____________end outer search loop______________
	///////////////////////////////////////////////////
	if( inputResult.size() == 1 ) { inputResult.remove(0); }
    }

    /**
     * Speed optimisations are implemented by using different iterators. In the
     * first step possible iterators are extracted from the query. Then the
     * iterators not supported by all minterms are discarded. At last for every
     * variable the fastest iterator is selected. This may requires that the
     * free variable must be new sorted.
     */
    class PossibleIterator
    {
	public int    mintermNr,
	    type;
	public String variable,
	    neededVariable;

	public PossibleIterator( int    type,
				 String variable,
				 String neededVariable,
				 int    mintermNr )
	{
	    this.type           = type;
	    this.variable       = variable;
	    this.neededVariable = neededVariable;
	    this.mintermNr      = mintermNr;
	}

	public boolean equals(Object obj)
	{
	    try {
		PossibleIterator iterator = (PossibleIterator)obj;
		return    (type == iterator.type)
		    && variable.equals(iterator.variable)
		    && neededVariable.equals(iterator.neededVariable);
	    } catch( ClassCastException e ){ return false; }
	}

	public double getRating()
	{
	    switch(type){
	    case ITERATOR_TYPED_ELEMENTS:       return 0.2;
	    case ITERATOR_ELEMENTS_DOMINATED:   return 0.10;
	    case ITERATOR_ELEMENTS_DOMINATING:  return 0.15;
	    case ITERATOR_ELEMENTS_POINTED:     return 0.02;
	    case ITERATOR_ELEMENTS_OF_SUBGRAPH: return 0.18;
	    default:                            return 1;
	    }
	}
    }

    public void addProgressListner(ProgressListener listener)
    {
	if( !progressListeners.contains(listener) ){
	    progressListeners.add(listener);
	}
    }

    public void removeProgressListner(ProgressListener listener)
    {
	if( progressListeners.contains(listener) ){
	    progressListeners.remove(listener);
	}
    }

    /**
     * Shows the disjunctive normal form of the query.
     * For preprocessing the given query, a combination of conditions, will be
     * converted to disjunctive normal form (DNF).
     * @param query the query string
     * @return how the disjunctive normal form of the query looks
     * @throws Throwable lexical or syntax error of parsing the query
     */
    public String showDNF(String query) throws Throwable
    {
	NodeQuery n = ( new Parser( new StringReader(query+"\n") ) ).Query();
	NodeSimpleQuery sq = (NodeSimpleQuery)n.jjtGetChild(0);
	NodeLogical nl = (NodeLogical)sq.jjtGetChild(0);
	List dnf = nl.dnf;
	String ret = "";
	for (int i=0; i<dnf.size(); i++) {
	    List l = (List)dnf.get(i);
	    for (int j=0; j<l.size(); j++) {
		if ( ((NodeCondition)l.get(j)).isNegated ) {
		    ret += "!";
		}
		ret += ((SimpleNode)l.get(j)).image + " ";
	    }
	    if ( i != (dnf.size() - 1) ) { ret += "\n"; }
	}

	return ret;
    }

    /**
     * Sows the parsing tree of the query.
     * For preprocessing the given query string will be parsed by the
     * {@link Parser} generated by
     * <a href="http://www.webgain.com/products/java_cc/">JJTree and JavaCC</a>.
     * The result of parsing is a tree which could be shown by this methode.
     * @param query the query string
     * @param prefix every line of return will start with this prefix
     * @return the parsing tree of the query
     * @throws Throwable lexical or syntax error of parsing the query
     */
    public String showParseTree(String query, String prefix) throws Throwable
    {
	Parser parser = new Parser( new StringReader(query+"\n") );
	NodeQuery n = parser.Query();
	return parser.Query().dump(prefix);
    }

    /** Returns the first query parsing tree child node of the specified node of
     *  the specified type. */
    private Node getChild(Node node, String type)
    {
	Node ret = null;
	if( node.jjtGetNumChildren() > 0 ) {
	    for( int i=0; i<node.jjtGetNumChildren(); i++) {
		if( node.jjtGetChild( i ).toString().equals( type ) ) {
		    ret = node.jjtGetChild( i );
		    break;
		}
	    }
	}
	return ret;
    }

    /**
     * Converts the result of search(...) into a flat list of lists.
     * The result of a simple query will be unchanged. The result of a complex
     * query will be converted in such a way that it is equale to a simple
     * query.<br>
     * E.g.: The result <b>{</b>{"$a"}, {e1, <b>{</b>{"$b"}, {e2}, {e3}<b>}</b>},
     * {e4, <b>{</b>{"$b"}, {e5}<b>}</b>} is converted to  <b>{</b>{"$a", "b"},
     * {e1, e2}, {e1, e3}, {e4, e5}<b>}</b>.
     * @param result the result of search(...)
     */
    static public void flattenListOfResults(List results)
    {
	while(  (results.size() > 1)
		&& ( ((List)results.get(0)).size()
		     < ((List)results.get(1)).size() ) ) {

	    // add second level to first level variable names
	    List firstResult = (List)results.get(1);
	    ((List)results.get(0)).addAll(
					  (List)((List)firstResult.get( firstResult.size()-1 )).get(0) );

	    // permutation first with second level results
	    for( int i=results.size()-1; i>=1; i-- ) {
		List firstLevel  = (List)results.remove(i);
		List secondLevel = (List)firstLevel.remove( firstLevel.size()-1 );
		for( int j=secondLevel.size()-1; j>=1; j-- ) {
		    List permutation = new ArrayList();
		    permutation.addAll(firstLevel);
		    permutation.addAll( (List)secondLevel.get(j) );
		    results.add(i, permutation);
		}
	    }
	}
    }

    /**
     * Returns a result converted to XML.
     * E.g.: The result {{"$a"}, {e1, <b>{</b>{"$b"}, {e2}, {e3}<b>}</b>}, {e4,
     * <b>{</b>{"$b"}, {e5}<b>}</b>}<br> is converted to:<br>
     * <tt>&lt;?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?&gt;<br>
     * &lt;matchlist size="2"&gt;<br>
     * &nbsp;&nbsp;&lt;match n="1"&gt;<br>
     * &nbsp;&nbsp;&lt;nite:pointer role="a" xlink:href="file1.xml#e_1"/&gt;<br>
     * &nbsp;&nbsp;&lt;matchlist size="2"&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;nite:pointer role="b" xlink:href="file1.xml#e_2"/&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;nite:pointer role="b" xlink:href="file1.xml#e_3"/&gt;<br>
     * &nbsp;&nbsp;&lt;/matchlist&gt;<br>
     * &nbsp;&nbsp;&lt;nite:pointer role="a" xlink:href="file1.xml#e_4"/&gt;<br>
     * &nbsp;&nbsp;&lt;matchlist size="1"&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;nite:pointer role="b" xlink:href="file1.xml#e_5"/&gt;<br>
     * &nbsp;&nbsp;&lt;/matchlist&gt;<br>
     * &lt;/matchlist&gt;</tt><br>
     * @param result the result of search(...)
     * @return result converted to XML
     */
    static public String resultToXML(List result)
    {
	StringBuffer ret = new StringBuffer(XML_HEAD);
	ret.append( resultToXML(result, "", false, -1) );
	return ret.toString();
    }

    /**
     * Returns a result converted to XML.
     * E.g.: The result {{"$a"}, {e1, <b>{</b>{"$b"}, {e2}, {e3}<b>}</b>}, {e4,
     * <b>{</b>{"$b"}, {e5}<b>}</b>}<br> is converted to:<br>
     * <tt>&lt;?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?&gt;<br>
     * &lt;matchlist size="2"&gt;<br>
     * &nbsp;&nbsp;&lt;match n="1"&gt;<br>
     * &nbsp;&nbsp;&lt;nite:pointer role="a" xlink:href="file1.xml#e_1"/&gt;<br>
     * &nbsp;&nbsp;&lt;matchlist size="2"&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;nite:pointer role="b" xlink:href="file1.xml#e_2"/&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;nite:pointer role="b" xlink:href="file1.xml#e_3"/&gt;<br>
     * &nbsp;&nbsp;&lt;/matchlist&gt;<br>
     * &nbsp;&nbsp;&lt;nite:pointer role="a" xlink:href="file1.xml#e_4"/&gt;<br>
     * &nbsp;&nbsp;&lt;matchlist size="1"&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;nite:pointer role="b" xlink:href="file1.xml#e_5"/&gt;<br>
     * &nbsp;&nbsp;&lt;/matchlist&gt;<br>
     * &lt;/matchlist&gt;</tt><br>
     * @param result the result of search(...)
     * @param max maximum of matches to convert
     * @return result converted to XML
     */
    static public String resultToXML(List result, long max)
    {
	StringBuffer ret = new StringBuffer(XML_HEAD);
	ret.append( resultToXML(result, "", false, max) );
	return ret.toString();
    }
    static private StringBuffer resultToXML(List result, String prefix, boolean sub, long max)
    {
	Iterator     it       = result.iterator();    // iterator
	List         varNames = result.isEmpty() ?    // list of variable names
	    new ArrayList() :
	    (List)it.next();
	StringBuffer ret      = new StringBuffer();   // return

	// matchlist head
	ret.append(prefix);
	ret.append("<matchlist");
	if( sub ){ ret.append(" type=\"sub\""); }
	ret.append(" size=\"");
	ret.append( result.isEmpty() ? 0 : result.size()-1 );
	ret.append("\"");
	if( !sub ){ ret.append(" " + NITE_NAMESPACE_NAME + "=\"" + NITE_NAMESPACE + "\""); }
	// if( !sub ){ ret.append(xmlns:nite=\"http://nite.sourceforge.net/\""); }
	ret.append(">\n");

	long    i       = 1;
	boolean stopped = false;
	while(  it.hasNext() ) {

	    // stop at maximum
	    if( (max>0) && (i>max) ) { stopped = true; break; }

	    // match head
	    ret.append(prefix);
	    ret.append("  <match n=\"");
	    ret.append(i);
	    ret.append("\">\n");

	    // match
	    List match = (List)it.next();
	    for(int j=0; j<varNames.size(); j++) {

		String xLink = "";
		try {
		    xLink = ((net.sourceforge.nite.nom.nomwrite.NOMElement)match.get(j)).getXLink();
		} catch( ClassCastException e ){
		    //          xLink = ((net.sourceforge.nite.jnom.JNOMElement)match.get(j)).getXLink();
		}
		//        NOMElement x = (NOMElement)match.get(j);
		ret.append(prefix);
		ret.append("    <nite:pointer role=\"");
		ret.append( triggerExpression(
					      varNames.get(j).toString().substring(1) ) );
		ret.append("\" href=\"");
		ret.append( xLink );
		ret.append("\"/>\n");
	    }

	    // submatchlist
	    if(match.size() > varNames.size()) {
		ret.append( resultToXML( (List)match.get( match.size()-1 ),
					 "    " + prefix,
					 true,
					 max ) );
	    }

	    //match footer
	    ret.append(prefix);
	    ret.append("  </match>\n");

	    i++;
	}

	//matchlist footer
	if(stopped) {
	    ret.append(prefix);
	    ret.append("  ...\n");
	}
	ret.append(prefix);
	ret.append("</matchlist>\n");

	return ret;
    }

    /** Converts special characters into HMTL syntax */
    private static String triggerExpression(String expression) {
	StringBuffer result = new StringBuffer();
	char c;
	for (int i=0; i<expression.length(); i++) {
	    c = expression.charAt(i);
	    switch (c) {
	    case '&': { result.append("&amp;");  break; }
	    case '"': { result.append("&quot;"); break; }
	    case '\'':{ result.append("&apos;"); break; }
	    case '<': { result.append("&lt;");   break; }
	    case '>': { result.append("&gt;");   break; }
	    default:  { result.append(c); }
	    }
	}
	return result.toString();
    }


}
