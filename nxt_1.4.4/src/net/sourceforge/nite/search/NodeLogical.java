package net.sourceforge.nite.search;

import java.util.*;

/* Generated By:JJTree: Do not edit this line. NodeLogical.java */

/**
 * Generated by the
 * <a href="http://www.webgain.com/products/java_cc/" target="_blank">JavaCC</a>
 * tool JJTree.
 */
public class NodeLogical extends SimpleNode {
    public NodeLogical(int id) {
        super(id);
    }

    public NodeLogical(Parser p, int id) {
        super(p, id);
    }

    ////////////////////////////////////////////////

    public  Vector dnf              = new Vector();
    public  Vector dnf2             = new Vector();

    /// NM 2006 A new structure which we can use in rewriting, rather than the full DNF form:
    //public Vector rewrDNF = new Vector();
    public Vector logicals = new Vector();
    public static String OR  = "OR";
    public static String AND = "AND";
    /// When Conditions are negated in negateDNF - record changes in logical relations here???

    public void addOrElement(NodeCondition element)
    {
        logicals.add(OR);
        //System.out.println("\nadding OR element "+element);
        List l = new Vector();
        l.add( element );
        //    dnf.add( l );

        if (dnf2.isEmpty() ) { dnf2.add( new Vector() ); }
        ((List)dnf2.lastElement()).add( l );
    }

    public void addAndElement(NodeCondition element)
    {
        logicals.add(AND);
        //System.out.println("\nadding AND element\n"+element);
        //((List)dnf.lastElement()).add(element);
        ((List)((Vector)dnf2.lastElement()).lastElement()).add(element);
    }

    public void addImplicationElement(NodeCondition element)
    {
        List l = new Vector();
        dnf2.add( l );
        addOrElement(element);
    }

    /**
     * Makes disjunctive normal form by applying distributive rules,
     * and DeMorgan's laws via negateDNF().
     * 
     * Called once a NodeLogical has been created, by the creating class.
     */
    public void makeDNF()
    {
		//System.err.println("======================================================\nREWRITING WITH MAKEDNF");
        //System.err.println("===\nDNF BEFORE MAKEDNF():\n"+dnf+"\n===\n");

        // Add to dnf the contents of every element in dnf2, first negating dnf if we have already added to it.
        dnf.removeAllElements();
        for( int i=0; i<dnf2.size(); i++ ) {
            //if( i>0 ) { dnf = (Vector)negateDNF( dnf ); }
            if( i>0 ) negateDNF();
			//System.out.println("MAKE DNF: Adding to DNF the contents of dnf2.get("+i+"):\n"+(List)dnf2.get(i) );
            dnf.addAll( (List)dnf2.get(i) );
        }
        //System.err.println("DNF after negation:\n"+dnf+"\n");
		//System.err.println("DNF after all DNF2 elements added:\n"+dumpDNFVector(dnf, "  ")+"\n");
        /*
          System.out.println("---");
          for (int i=0; i<dnf.size(); i++) {
          List l = (List)dnf.get(i);
          for (int j=0; j<l.size(); j++) {
          NodeCondition nc = (NodeCondition)l.get(j);
          try {
          System.out.println( ((NodeLogical)nc.jjtGetChild(0)).dnf  );
          } catch (Throwable tw) {
          System.out.println( "??? " + nc.jjtGetNumChildren()  );
          }
          }
          System.out.println( "" );
          }*/
        for (int i=0; i<dnf.size(); i++) {
            List l = (List)dnf.get(i);
            //System.err.println("LIST   l=dnf.get("+i+"):\n"+l);
            for (int j=0; j<l.size(); j++) {
                //List<->NodeCondition
                //NodeCondition nc = (NodeCondition)l.get(j);
                if (  l.get(j).getClass().equals(Vector.class)
                      || ((NodeCondition)l.get(j)).isGroup ) {
                    Vector group = l.get(j).getClass().equals(Vector.class) ?
                        (Vector)l.get(j) :
                        ((NodeLogical)((NodeCondition)l.get(j)).jjtGetChild(0)).dnf;
                    dnf.remove(i); //remove l
                    //System.err.println("GROUP Handling "+j+":\n"+group);

                    // Gradually modify dnf element i (also referenced by List l above, which is also used/modified below) 
                    // to include all the subconditions of the group (condition j within that element i). These are found 
                    // in the dnf of the NodeLogical under the group condition.
                    for (int k=group.size()-1; k>=0; k--) {
                        Vector newList = new Vector();
                        //start
                        newList.addAll( l.subList(0, j) );
                        //insert
                        newList.addAll( (List)group.get(k) );
                        //end
                        newList.addAll( l.subList( j+1, l.size() ) );
                        dnf.add(i, newList);
						//System.err.println("[MAKE DNF - GROUP CONDITION "+j+", ELEMENT "+k+"]  l=dnf.get("+i+") is "+l);
                    }
                    //System.err.println("GROUP Updated dnf.get("+i+"):\n"+dnf.get(i));
                }
                //update l
                l = (List)dnf.get(i);
            }
            //System.err.println("LIST   l=dnf.get("+i+"):\n"+l);
        }
        //System.err.println("===\nDNF AFTER MAKEDNF():\n"+dnf+"\n===\n");

        /*
          System.out.print(" >>>DNF>>> ");
          for (int i=0; i<dnf.size(); i++) {
          List l = (List)dnf.get(i);
          for (int j=0; j<l.size(); j++) {
          //if ( ((NodeCondition)l.get(j)).isNegated ) {
          //  System.out.print("!");
          //}
          //System.out.print( ((SimpleNode)l.get(j)).image + " " );
          System.out.print( l.get(j) + " " );
          }
          if ( i != (dnf.size() - 1) ) { System.out.print( " + " ); }
          }
          System.out.println("");
        */
    }


    /**
     * Constructs Vectors representing every possible permutation of 
     * the negated conditions of the dnf; each is added to the new DNF.
     * 
     * Appears to provide the full disjunctive normal form for this logical node....?
     * 
     * Called by NodeCondition.negate() on group conditions only. 
     * Also called by NodeLogical.makeDNF() on dnf, for every element of dnf2 but the first.
     */
    public void negateDNF() {
        dnf = (Vector)negateDNF(dnf);
    }
    public List negateDNF(List dnf) {
        //System.err.println("DNF before negation:\n"+dnf+"\n");
        //System.err.println("DNF2 before negation:\n"+dumpDNFVector(dnf2, "")+"\n");
        //System.out.println("ggggggggggggggggggr" + dnf.size());
        Vector newDnf = new Vector();
        // an array recording what ..??
        int[] i = new int[ dnf.size() ];
        // set all initial i to zero
        for (int j=0; j<i.length ; j++) { i[j]=0; }

        //all permutation
        boolean hasNext;
        // keep track of which conditions have been negated
        Vector alreadyNegated = new Vector();
        
        // Here we construct Vectors representing every possible permutation of 
        // the negated conditions of the dnf; each is added to the new DNF
        do {
            Vector permutation = new Vector();
            // For each Vector in the dnf, negate the i[j]-th condition in the j-th Vector
            for (int j=0; j<i.length; j++) {
                // get the i[j]-th condition in the j-th vector in the dnf ???
                NodeCondition element = (NodeCondition)((List)dnf.get(j)).get(i[j]);
                // negate the condition if it hasn't been negated yet 
                // (if the condition is a group, NodeCondition.negate() calls this method again)
                if ( !alreadyNegated.contains(element) ) {
                    element.negate();
                    alreadyNegated.add(element);
                }
                // add the condition to the permutations
                permutation.add(element);
            }
            // add the Vector of negated conditions to the newDnf
            newDnf.add(permutation);
            //System.out.println("PERMUTATION: "+permutation);
            //i++

            // If there are any conditions left undone?? in any of the dnf's 
            // Vectors (checking from last to first), carry on negating.
            hasNext = false;
            for (int j=(i.length-1); j>=0 ; j--) {
                // if the count?? < last index of the j-th Vector in the dnf,
                // increment it and do the next perm??
                if ( i[j] < ( ((List)dnf.get(j)).size() - 1 ) ) {
                    i[j]++;
                    hasNext = true;
                    break;
                } else {
                    // reset the count?? if we have done all the conditions in the j-th Vector of the dnf ???
                    i[j] = 0;
                }
            }
        } while (hasNext);
        //result: all permutations, each element negated
        //dnf = newDnf;
        //System.err.println("DNF after negation:\n"+newDnf+"\n");
        //System.err.println("DNF2 after negation:\n"+dumpDNFVector(dnf2, "")+"\n");
        return newDnf;
    }

    /** 
     * 
     * 
     * Note we do not actually restructure dnf2, but change the logical relationships
     * between conditions which are recorded in the logicals variable. This must also be done 
     * for the dnf2 of any of the conditions which are also groups of conditions.
     * 
     * This method is called only upon groups (from NodeCondition.negate()).
     */
    public void negateDNF2() { 
        // The conditions themselves are negated by negateDNF()
        // We should just switch the logicals in any group node which hasBeenNegated ???
        // If a group node contains only a group node, we should reverse the logicals in that next level instead
        //System.err.println("logicals before negateDNF2: "+logicals);
        //NodeCondition firstElement = (NodeCondition)((List)dnf.get(0)).get(i[j]);
        // negate the dnf2 of any group conditions which are children of this group condition
        //System.out.println("DNF2: "+dnf2);
        List myDNF = (List)dnf2.get(0);
        // for each vector within this, check the children conditions for groupness
        for (int i=0; i<myDNF.size(); i++) {
            List list = (List)myDNF.get(i);
            // check each condition
            for (int j=0; j<list.size(); j++) {
                NodeCondition element = (NodeCondition)list.get(j);
                if (element.isGroup) ((NodeLogical)element.jjtGetChild(0)).negateDNF2();
            }
        }
        // invert the logical relationships in this dnf2 (except for the initial OR)
        for (int i=0; i<logicals.size(); i++) {
            if (i==0) continue;
            logicals.set(i, (logicals.get(i).equals(OR)?AND:OR) );
        }
        //System.err.println("logicals after negateDNF2: "+logicals);

        /////////////////////////////////////////////
        /*
        for (int j=0; j<i.length; j++) {
            // get the i[j]-th condition in the j-th vector in the dnf ???
            NodeCondition element = (NodeCondition)((List)dnf.get(j)).get(i[j]);
            // negate the condition if it hasn't been negated yet 
            // (if the condition is a group, NodeCondition.negate() calls this method again)
            if ( !alreadyNegated.contains(element) ) {
                element.negate();
                alreadyNegated.add(element);
            }
            // add the condition to the permutations
            permutation.add(element);
        }
        // add the Vector of negated conditions to the newDnf
        //newDnf.add(permutation);
        */
    }


    /**
     * Overrides the method in SimpleNode. Prints the contents of 
     * a NodeLogical, including AND/OR operators.
     * 
     * @author nmayo@inf.ed.ac.uk
     */
    public String dump(String prefix) {
        String ret = prefix+"LOGICAL\n";
        /// This version uses the Condition children[] of the NodeLogical, 
        /// and those of further NodeLogicals below Conditions
        /// if there are children, add them to the string with appropriate logical connections.
        /// Logical AND/OR comes from the logicals Vector.
        if (children != null) {
            for (int i = 0; i < children.length; ++i) {
                SimpleNode n = (SimpleNode)children[i];
                if (n != null) {
                    // if the child is a NodeCondition (which it should always be..?) append it to the string with a logical AND/OR
                    if (n instanceof NodeCondition && i>0) {
                        //String logical = (logicals.isEmpty()) ? "" : logicals.remove(0).toString();
                        String logical = logicals.get(i).toString();
                        ret+=prefix+dumpSpacer+logical+"\n"+n.dump(prefix+dumpSpacer);;
                    } else ret += n.dump(prefix+dumpSpacer);
                }
            }
        }
        return ret;
    }



    /** 
     * Dump a representation of the disjunctive normal form Vector,
     * which contains information pertaining to the logical joins 
     * between conditions.
     * 
     * @author nmayo@inf.ed.ac.uk
     */
    public String dumpDNFVector(Vector nf, String prefix) {return dumpDNFVector(nf, 0);}
    public String dumpDNFVector(Vector nf, int level) {
        String spacer = " ";
        StringBuffer levelSpacer = new StringBuffer(""); for (int i=0; i<(2*level); i++) {levelSpacer.append(spacer);}
        String ret = "{"+spacer;
        int nfsize = nf.size();
        level++;
        int id = 0;
        for (int j=0; j<nfsize; j++) {
            //if (j>0) ret+="\n"+levelSpacer+logicals.get(j);
            Object o = nf.get(j);
            if (o instanceof Vector) {
                if (j>0) ret+="\nV"+levelSpacer;
                ret+=dumpDNFVector((Vector)o, level);
            }
            if (o instanceof NodeCondition) {
                // add a logical AND/OR
                if (j>0) ret+="\n"+levelSpacer+logicals.get(id++);
                NodeCondition nc = (NodeCondition)o;
                ret+="\n"+levelSpacer+nc.toString()+"\n"+levelSpacer;
                Node[] kids = nc.children;
                int l = 0;
                if (kids!=null) l = kids.length;
                for (int i=0; i<l; i++) {
                    Node n = kids[i];
                    if (n instanceof NodeLogical) ret+=dumpDNFVector(((NodeLogical)n).dnf2, level);
                }
            }
        }
        return ret+spacer+"}";
    }


    /** Common spacing unit for calls to dump() methods. */
    private String dumpSpacer = "   ";


}
