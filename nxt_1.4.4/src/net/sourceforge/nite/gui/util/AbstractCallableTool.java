/**
 * Natural Interactivity Tools Engineering
 * Copyright (c) 2004, 
 * See the README file in this distribution for licence.
 */
package net.sourceforge.nite.gui.util;


//NXT imports
import net.sourceforge.nite.gui.transcriptionviewer.*;
import net.sourceforge.nite.util.*;
import net.sourceforge.nite.nxt.*;
import net.sourceforge.nite.gui.mediaviewer.*;
import net.sourceforge.nite.meta.impl.*;
import net.sourceforge.nite.meta.*;
import net.sourceforge.nite.nom.*;
import net.sourceforge.nite.nom.nomwrite.*;
import net.sourceforge.nite.nom.nomwrite.impl.*;
import net.sourceforge.nite.time.*;
import net.sourceforge.nite.search.*;
import net.sourceforge.nite.query.*;
import net.sourceforge.nite.gui.util.*;

//help imports
import javax.help.*;

//general java imports
import java.net.URL;
import java.awt.Frame;
import java.awt.Rectangle;
import java.awt.Dimension;
import java.awt.event.*;
import javax.swing.*;
import java.util.Set;
import java.util.Iterator;
import java.util.List;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.logging.*;
import java.awt.*;
import java.io.*;
import org.xml.sax.SAXException;

//look and feels
import java.awt.Toolkit;
import javax.swing.*;
import com.jgoodies.looks.plastic.*;
import com.jgoodies.looks.plastic.theme.*;
import com.jgoodies.looks.*;

//CVS
//import com.ice.cvsc.*;
//import com.ice.jcvsii.*;

/**
 * DOCUMENTATION UNDER CONSTRUCTION. NEED HELP? ASK dennisr at hmi dot utwente dot nl
 * <br>
 * A general abstract class that implements a lot of the default support for annotation tools.
 * It is targeted at observation-related callable tools such as a dialogue act coder or
 * named entity coder.
 * <p>
 * Main functionalities: 
 * <ul>
 *  <li>A subclass of AbstractCallableTool can be used as a CallableTool in a NXT corpus.
 *  <li>CallableTool defines a number of methods that help you to create many default functionalities in 
 *      a new tool, such as a transcription view, a media player, a log/feedback window, default menu functions, etc.
 *      (see below: overriding AbstractCallableTool)
 *  <li>It defines support for configuration on corpus-level (settings in a configuration xml-file that 
 *      customize a tool for a specific corpus, naming relevant layers etc.)
 *  <li>It defines support for annotator-specific layers, allowing multiple annotators to share the same copy of a
 *      corpus since the annotations that they create are stored separately per anntoator. 
 *  <li>It defines support for directly coupling tools to a CVS repository for a given corpus. This allows a corpus
 *      manager to configure the tools/corpora in such a way that new annotations are automatically committed on
 *      the central CVS server under a directory appropriate for the annotator that created them.
 * </ul>
 * <hr>
 * The rest of this documentation addresses each point in more detail. At the end a short section goes into even more 
 * detail regarding implementation issues for new tools that subclass this AbstractCallableTool class.
 * <br>
 * <h2>Using an existing tool implementation in a corpus</h2>
 * This part of the documentation should maybe be put somewhere else...
 * <h3>Global Metadatafile entry</h3>
 * Example for dialogue act coder:
 <pre>
        &lt;callable-program description="Dialogue Act Annotation" name="net.sourceforge.nite.tools.dacoder.DACoder"&gt;
            &lt;required-argument name="corpus" type="corpus"/&gt;
            &lt;required-argument name="observation" type="observation"/&gt;
        &lt;/callable-program&gt;
 </pre>
 * toolname (class), corpus and observation are generally a required argument (most annotation tools operate on one 
 * recording at a time)
 * <h3>Specific annotators</h3>
 * CallableTool Entry gets one more option: 
 <pre>
            &lt;required-argument name="annotator" type="annotator"/&gt;
 </pre>
 * If set, annotator is asked for name, and the codings that are <i>annotator specific</i> (e.g. in DACoder this would be 
 * the dialogue act file and the adjacency pair file) are loaded especially for that coder and saved in a separate 
 * directory. This means that the current coder will not see the data from these layers generated by annotators with other 
 * name, and other annotators will not see results of this annotator. This prevents mixup of multiple versions of the same 
 * annotation created by different people.
 * <br>QUESTION: Which layers are loaded/saved separately for this anntoator?
 * <br>ANSWER: That is dependent on the specific tool subclass. Each implementation of AbstractCallableTool implements
 * a function called {@link #initNomAnnotatorSpecificLoads}. E.g. in the DACoder that method is implemented to set exactly
 * those codings to be annotator specific that contain the dialogue acts and the adjacency pairs.
 * <h3>usecvs</h3>
 * CallableTool Entry gets one more option: (not entirely stable yet)
 <pre>
            &lt;required-argument default="true" name="usecvs"/&gt;
 </pre>
 * If set, the tool will try, upon startup, to get the latest version of the relevant codings
 * <br>QUESTION: What is the advantage of this?
 * <br>ANSWER: Well, this means that the annotator can continue working on the annotations on a different computer tomorrow,
 * without having to worry about copying files etc. He/she alwyas has the latest versions of his/her work available.
 * Furthermore, the corpus manager will also always have access to the latest material.
 * <br>QUESTION: Which layers get committed TO the server on closing the tool?
 * <br>ANSWER: Exactly those layers that are 'annotator specific', i.e. generally those layers that
 * are being annotated. (Dialogue acts, emotions, whatever...)
 * <br>QUESTION: Which layers get updated/copied FROM the server on starting the tool?
 * <br>ANSWER: Everything. (for now :-) ) (that will change)
 * <h3>configuration of tools for a specific corpus</h3>
 * It is possible to configure one of these tools for a specific corpus. Reasons to do this might be for example
 * the fact that a tool needs to know what the name of a specific layer is (e.g. the DACoder needs to know the name of
 * the layer containing Dialogue Acts). The reader is referred to another section in this documentation that discusses 
 * this issue. 
 * <h2>Configuration of tools: hardcoded settings and user-configurable settings</h2>
 * Config class, config file; settings that should be changed by corpus developer, settings that may be changed by annotator
 * A MyAbstractCallableTool gets its settings from a corresponding MyAbstractCallableToolConfig, created in a overridden 
 * version of 'initConfig()'. This config object is initialized with the name of the metadatafile of the currently loaded
 * corpus. This config object can define any number of convenience methods such as 'getDialogActLayer'
 * or 'getTranscriptionElementName' that return the appropriate values. These values are either hardcoded (e.g. selection 
 * strategies in DACoder), or taken from the settings defined in the nxtConfig.xml configuration file.
 * <h3>toolconfig setting in metadata file</h3>
 * CallableTool Entry can get one more option:
 <pre>
            &lt;required-argument default="myConfigFileName.xml" name="config"/&gt;
 </pre>
 * If set, the tool will try to load the specified configuration file rather than the default nxtConfig.xml.
 * further to this, the specific corpus and gui-settings within the configuration file can be named with two more <em>required-argument</em> in the CallableTool:
<pre>
          &lt;required-argument name="corpus-settings" default="my-corpus-settings-id"/>
          &lt;required-argument name="gui-settings" default="my-gui-settings-id"/>
</pre>
 * the first naming the ID of the corpus-settings node in the config
 * file that should be used, the second naming the ID of the
 * gui-settings node.
 * <h2>Default functionalities in this class; how to invoke these functionalities in a SIMPLE subclass</h2>
 * New tool MyCallableTool.
 * needed: main function (show example)
<pre>
     **
     * The main method for a subclassing tool is probably always the same: simply call
     * the constructor and pass any arguments.
     *
    public static void main(String[] args) {
        DACoder mainProg = new DACoder(args);
    }
</pre>
 * needed: proper constructor calling a list of functions (show list, explain if each is necessary, optional, how and why)
 * a config object!!!!
<pre>
     **
     * This method starts with parsing the arguments passed to this tool, after which it calls
     * all those useful methods from the superclass that make development of a new tool such an
     * easy process.
     *
    public DACoder(String[] args) {
        //* mostly necessary: *
        parseArguments(args); //AbstractCallableTool.parseArguments parses the usual arguments: corpus, observation, annotator, usecvs.
        initConfig(); //cfreate the tool specific configuration class
        initializeCorpus(getCorpusName(),getObservationName(), getAnnotatorName()); //initialize the corpus, given the settings passed as arguments
        setupMainFrame(getConfig().getApplicationName()); //setup a main frame 
        initLnF(); // Look and feel. Can be ignored/left out if you happen to like the default metal look-and-feel
        setupDesktop(); //setup a desktop on which all the windows (media viewer, transcription view, etc) are added
        
        //* pretty much optional: *
        setupLog(Logger.global, 530, 535, 465, 90); //a logging window, useful for giving feedback to the user
        setupMediaPlayer(695,15,300,400); //a mediaplayer: necessary if you want video or audio players synchronized to the transcription view
        setupTranscriptionView(15,15,500,600); //one of the most important elements for many tools: a view of the transcription. Highly customizable in the methods initTranscriptionView and refreshTranscriptionView.
        setupSearch(); //search functinoality can be included by default in all subclassing tools. Search results can be highlighted in the transcription view.
        setupActions();
        setupMenus();
        
        //* setup any tool specific extras... *

    } 
     **
     * The config method creates a configuration object specific for this subclass.
     * More information on this configuration stuff can be found below.
    protected void initConfig() {
        config = new DACoderConfig();
    }
</pre>
 * The documentation of the methods called in the above example constructor should help a lot in deciding 
 * whether (and how) to use them. 
 * In many cases the utility methods make some asssumptions about what has been called before 
 * (e.g. the setupVideo should be called AFTER the corpus has been initialized /loaded etc).
 * Keep track of this by reading javadoc!
 * needed: config class / config file settings. See other section for this.
 * <h2>Subclassing this AbstractCallableTool: more details</h2>
 * What are the most usual functions to override and extend?
 
 setupMenus, setupActions, initTranscriptionView, some setupToolSpecific method for a few extra panels and buttons...
 
 * @author Dennis Reidsma, UTwente
 */
public abstract class AbstractCallableTool {
    
/*==================================================================================
                APPLICATION START
                
  This section includes the methods to start the tool from the general NXT start-panel
  and the stuff needed to properly load the observation from the corpus.
 ==================================================================================*/
    protected String ICON_NAME="/net/sourceforge/nite/icons/logo/nxtlogo32.gif";

    protected AbstractCallableToolConfig config;
    public AbstractCallableToolConfig getConfig() {
        if (config == null) initConfig();
        return config;
    }
    protected void initConfig() {
        config = new AbstractCallableToolConfig();
    }
    
    /* name of the corpus and observation */
    String corpusname;
    public String getCorpusName() {
        return corpusname;
    }
    String observationname;
    public String getObservationName() {
        return observationname;
    }
    String annotatorname = null;
    public String getAnnotatorName() {
        return annotatorname;
    }
    boolean usecvs = false;
    public boolean useCVS() {
        return usecvs;
    }
    String configFileName  =null;
    public String getConfigFileName() {
        return configFileName;
    }
    String corpusSettingsName=null;
    public String getCorpusSettingsName() {
        return corpusSettingsName;
    }
    String guiSettingsName=null;
    public String getGUISettingsName() {
        return guiSettingsName;
    }


    /* The corpus */
    NOMWriteCorpus nom;
    public NOMWriteCorpus getCorpus() {
        return nom;
    }

    /* The corpus meta data */
    NiteMetaData metadata;
    public NiteMetaData getMetaData() {
        return metadata;
    }
    /* Video and synchronization clock */
    Clock niteclock;
    public Clock getClock() {
        return niteclock;
    }

    
    /**
     * This method parses the 'usual' arguments passed to an abstractcallabletool
     * and stores them appropriately.
     * afterwards, if present in the arguments, the following attributes are set:
     * annotatorname, corpusname, observationname, usecvs, config.
     * Extend this method if you want to add extra arguments to your tool.
     */
    protected void parseArguments(String[] args) {
        List arglist = new ArrayList();
        for (int i = 0; i < args.length; i++) {
            arglist.add(args[i]);
        }
        
        int ci = arglist.indexOf("-corpus");
        int oi = arglist.indexOf("-observation");
        int ai = arglist.indexOf("-annotator");
        int ui = arglist.indexOf("-usecvs");
        int confi = arglist.indexOf("-config");
        int gi = arglist.indexOf("-gui-settings");
        int csi = arglist.indexOf("-corpus-settings");
        if ((ci < 0) || (oi < 0)) {
            usage();
        }
        corpusname = (String)arglist.get(ci+1);
        observationname = (String)arglist.get(oi+1);
        if (ai >= 0) {
            annotatorname = (String)arglist.get(ai+1);
            if (annotatorname.startsWith("-")) {
                annotatorname = "";
            }
        }
	usecvs=false;
        //if (ui >= 0) usecvs = Boolean.parseBoolean((String)arglist.get(ui+1));
	// removed by jonathan 7.3.05 since it's a Java 1.5 function...
        if (ui >= 0 && ((String)arglist.get(ui+1)).equalsIgnoreCase("true")) {
	    usecvs=true;
	}

	if (confi >= 0) {
	    configFileName = (String)arglist.get(confi+1);
	    if (configFileName.startsWith("-")) {
		configFileName = "";
	    }
	}

	// added by Jonathan Kilgour 8/4/5. not really sure if we
	// should check for these args even if there's no config arg,
	// but here we go: corpus settings...
	if (csi >= 0) {
	    corpusSettingsName = (String)arglist.get(csi+1);
	    if (corpusSettingsName.startsWith("-")) {
		corpusSettingsName = "";
	    }
	}

	// ...and gui-settings
	if (gi >= 0) {
	    guiSettingsName = (String)arglist.get(gi+1);
	    if (guiSettingsName.startsWith("-")) {
		guiSettingsName = "";
	    }
	}

        if (usecvs) { //DR: usecvs only with named annotator. Search for/remove this comment in this class to remove that behaviour
            if ((annotatorname==null) || (annotatorname=="")) {
                JOptionPane.showMessageDialog(null, "Error: the corpus metadatafile specifies that cvs should be used to synchronize the corpus, but no specific annotator was named. Usecvs only works with a named annotator");
                Debug.print("Error: the corpus metadatafile specifies that cvs should be used to synchronize the corpus, but no specific annotator was named. Usecvs only works with a named annotator. Usecvs will now be ignored.", Debug.WARNING);
                usecvs = false;
            }
        }
    }
        
    /**
     * Loads the corpus (given the name and observationname).
     * Pre: corpusname defined, observationname defined
     * Post: metadata defined, nom defined, corpusname defined, observationname defined, clock defined
     * if usecvs was true, the corpus info is updated from the cvs server
     */
    protected final void initializeCorpus(String c, String o) {
        corpusname=c;
        observationname=o;
    	//update config !!!
	if (guiSettingsName!=null) {
	    getConfig().setGUISettings(guiSettingsName);
	}
	if (corpusSettingsName!=null) {
	    getConfig().setCorpusSettings(corpusSettingsName);
	}
    	if (configFileName != null) {
    	    try {
    	        //config name: if it is a relative path, we assume that it is a path relative to the metadatafile.
    	        if (!(new File(configFileName).isAbsolute())) {
		    String par = new File(corpusname).getParent();
		    if (par!=null) {
			configFileName = par+"/"+configFileName;
		    } 
    	        }
    	        getConfig().loadConfig(configFileName);
    	    } catch (IOException ex) {
    	        Debug.print("Can't load config from file " + configFileName + " specified in metadata " + c + ", exiting. StackTrace:", Debug.ERROR);
    	        ex.printStackTrace();
                System.exit(0);
    	    } catch (SAXException ex) {
    	        Debug.print("Can't load config from file " + configFileName + " specified in metadata " + c + ", exiting. StackTrace:", Debug.ERROR);
    	        ex.printStackTrace();
                System.exit(0);
    	    }
    	} else { // load with a null config file (request config from user)
	    try {
		getConfig().loadConfig(configFileName);
	    } catch (Exception ex) {
    	        Debug.print("Can't load config file. Exiting. StackTrace:", Debug.ERROR);
    	        ex.printStackTrace();
                System.exit(0);
	    }
	}
    	getConfig().setMetaDataFile(c);
    	if (useCVS()) {
    	    readCVS();
    	}
    	try {
    	    metadata = new NiteMetaData(getCorpusName());
    	    Debug.print("Metadata loaded", Debug.DEBUG);
    	} catch (NiteMetaException nme) {
    	    nme.printStackTrace();
    	    throw new RuntimeException("Can't initialize metadata");
    	}
    	if (metadata.getCorpusType() == NMetaData.STANDOFF_CORPUS) {
    	    try {
		nom = new NOMWriteCorpus(metadata);
		NObservation obs = metadata.getObservationWithName(getObservationName());
		//nom.setLazyLoading(false);
		initNomAnnotatorSpecificLoads(nom);
		nom.loadData(obs);
                Debug.print("Corpus '" + getCorpusName() + "' loaded for observation '" + getObservationName() + "'.", Debug.DEBUG);
    	    } catch (NOMException nex) {
        		nex.printStackTrace();
    	        throw new RuntimeException("Error loading corpus");
    	    }
    	} else {
    	    throw new RuntimeException("This is a standalone or simple corpus: couldn't load NOM");
    	}
    	niteclock = new DefaultClock(metadata, getObservationName());
    }        
        
    /**
     * Determines which layers should be loaded as annotator specific.
     * This method by default does NOTHING.
     * This method gets called from initializeCorpus.
     * If you want something more complicated, override this method. 
     * <br>
     * For example, the DACoder does NOT use the 'annotatorSpecificCodings' config setting, but derived the 
     * appropriate codings from the names of the DA layer and AP and NE layers.
     * <br>
     * The following methods are available to use here:
     * <br><b>nom.forceAnnotatorCoding(annotatorname, {name of coding})</b>: 
     *     The given coding MUST be loaded annotator specific. If it doesn't exist for this annotator, don't
     *     load data for this coding.
     * <br><b>nom.preferAnnotatorCoding(annotatorname, {name of coding})</b>: 
     *     The given coding will preferably be loaded annotator specific. If it doesn't exist for this annotator, 
     *     load the 'main' data for this coding.
     * <br><b>nom.setDefaultAnnotator(annotatorname)</b>: Prefer the given anntoator for all codings, unless
     *     overridden by one of the above methods.
     * 
     */
    protected abstract void initNomAnnotatorSpecificLoads(NOMWriteCorpus nom) throws NOMException;

    /** 
     * This method will check whether the metadatafile is part of a cvs tree, and if so, 
     * do an update on the tree. File: stored in 'corpusname'.
     * This method is called just before loading the corpus, if 'usecvs' is true. 'usecvs' will
     * be true if in the metadata the argument '&lt;required-argument name="usecvs" default="true"/&gt;
     * was included. At the moment this implementation presents an awkward login dialog to the user.
     */
    protected void readCVS() {
        //DR: this method works. But the implementation is probably not optimal :-)
        if (true) return;
        if (getAnnotatorName()==null) { //DR: usecvs only with named annotator. Search for/remove this comment in this class to remove that behaviour
            Debug.print("ERROR: USECVS CURRENTLY ONLY WORKS WHEN AN ANNOTATOR IS SPECIFIED", Debug.WARNING);
            return;
        }
        //CVSUtil.readCVS(getCorpusName());
    }

    /** 
     * This method will check whether the metadatafile is part of a cvs tree, and if so, 
     * do a commit on the tree, or in some cases even an add-before-commit.
     * This method is called just before exiting the tool, in the exit-action, if 'usecvs' is true. 'usecvs' will
     * be true if in the metadata the argument '&lt;required-argument name="usecvs" default="true"/&gt;
     * was included.
     */
    protected void writeCVS() {
        //DR: this method works. But the implementation is probably not optimal :-)
        if (true) return;
        
        if (getAnnotatorName()==null) { //DR: usecvs only with named annotator. Search for/remove this comment in this class to remove that behaviour
            Debug.print("ERROR: USECVS CURRENTLY ONLY WORKS WHEN AN ANNOTATOR IS SPECIFIED", Debug.WARNING);
            return;
        }
        //CVSUtil.writeCVS(getCorpus(), getConfig().getAnnotatorSpecificCodings(), annotatorname, getMetaData().getObservationWithName(getObservationName()));
        

    }
    
    JFrame mainframe;
    protected JFrame getMainFrame() {
        return mainframe;
    }                
    JDesktopPane desktop;
    protected JDesktopPane getDesktop() {
        return desktop;
    }                
    /**
     * Setup main window. Closing listener etc and menus and desktop are NOT yet initialized!
     */
    protected void setupMainFrame(String title) {
    	//main frame
    	mainframe = new JFrame(title);

    	//add windows listener to the main frame in order to perform appropriate exit action
    	mainframe.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
    	
    	//set icon
        SwingUtils.getResourceIcon(mainframe, ICON_NAME,getClass());

        //maximize
      	mainframe.setExtendedState(Frame.MAXIMIZED_BOTH);

    	mainframe.setSize(new Dimension(1000, 700));
    	mainframe.setVisible(true);
    }        
    	
    /**
     * Setup Desktop.
     * Pre: mainframe initialized
     */
    protected void setupDesktop() {
    	//desktop
        desktop = new JDesktopPane();
    	desktop.setSize(new Dimension(1000, 700));
    	getMainFrame().getContentPane().add(desktop);
   }


    /**
     * Shows a message on the system error stream to tell how the tool should be started.
     */
    protected static void usage() {
    	Debug.print("Usage: java <<toolname>> -corpus <<metadata-filename>> -observation <<observation-name>> [-annotator <<annotator-name>>] [-usecvs (true|false)]", Debug.ERROR);
	    System.exit(0);
    }
   
//=========================== MEDIAPLAYER =============================================

    
    private NITEVideoPlayer mediaplayer = null;
    /**
     * Returns the media player, if it has already been created by a call to setupVideo().
     */
    protected NITEMediaPlayer getMediaPlayer() {
        return mediaplayer;
    }
    /**
     * Creates a NITEMediaPlayer including signal selection list for the
     * current corpus/observation and adds it to the current desktop at the given 
     * coordinates.
     * <p>Pre: Corpus should be loaded; desktop should be created.
     * <p>Post: The videoplayer is created and visible and can be retrieved using 
     * getMediaPlayer();
     */
    protected void setupMediaPlayer(int x, int y, int width, int height) {
        Debug.print("=======================================", Debug.DEBUG);
	
	niteclock.ensureVisible(new Rectangle(x,y,width,height), getDesktop());

        Debug.print("=======================================", Debug.DEBUG);
    }

    protected ClockFace clockFace = null;
    /** 
     * Returns the clockface of this class. A clockface is the 'play control panel'
     * for the video and audio, and in this tool for the virtual meeting animation as well.
     * Before you initialize this, you must have at least a mainframe, a desktop and an initialized 
     * corpus.
     */
    public ClockFace getClockFace() {
        //return clockFace;
        return (ClockFace)niteclock.getDisplay();
    }

//=========================== TRANCSRIPTIONVIEW =============================================


    private NTranscriptionView ntv = null;
    /**
     * Returns the transcription view, if it has already been created by a call to setupTranscriptionView().
     */
    public NTranscriptionView getNTV() {
        return ntv;
    }
    /**
     * Creates a NTranscriptionView and adds it to the desktop at the given coordinates.
     * <p>Pre: Corpus should be loaded; desktop should be created.
     * <p>Post: The transcriptionView is created and visible and can be retrieved using 
     * getNTV();
     * This abstractcallabletool assumes that you want to have at most one transcriptionview.
     * The contents and settings of the transcriptionview are determined by the methods
     * initTranscriptionViewSettings() and refreshTranscriptionView(). Those are the two methods
     * that you would most likely override to make sure that YOUR tool has exactly the right 
     * transcription display.
     */
    protected void setupTranscriptionView(int x, int y, int width, int height) {
       ntv=new NTranscriptionView();
       ntv.setClock(getClock());
       JInternalFrame ntvFrame = new JInternalFrame("Transcription", true, false, true, true);
       SwingUtils.getResourceIcon(ntvFrame, "/eclipseicons/obj16/text_edit.gif",getClass());
       JScrollPane scroller= new JScrollPane(ntv);
       ntvFrame.getContentPane().add(scroller);
       ntvFrame.setVisible(true);                    
       ntvFrame.setSize(width, height);
       ntvFrame.setLocation(x,y);
       getDesktop().add(ntvFrame);
       
       initTranscriptionViewSettings();
       refreshTranscriptionView();
    }    
    

    /**
     * Initializes the settings of the transcriptionView. This method does NOT fill the contents of the view.
     * The contents are filled in 
     * {@link project.ami.nxtutils.AbstractCallableTool#refreshTranscriptionView refreshTranscriptionView}.
     * This methods will be overriden by the implementations.
     * <p>
     * <b>WHAT SHOULD BE INITIALIZED?</b>
     
     See also new config classes
     */
    public void initTranscriptionViewSettings() {
        //display: word layer properties
        getNTV().setTransLayerName(config.getTranscriptionLayerName());
        getNTV().setTranscriptionToTextDelegate(config.getTranscriptionToTextDelegate());
        getNTV().setTranscriptionAttribute(config.getTranscriptionAttribute());
        
        //display: segment layer properties
        getNTV().setSegmentationElementName(config.getSegmentationElementName()); 
        getNTV().setSegmentToTextDelegate(config.getSegmentToTextDelegate());
        getNTV().setSegmentToTextAttribute(config.getSegmentToTextAttribute());

        //selection: selection strategies and properties
        getNTV().setWordlevelSelectionType(config.getWordlevelSelectionType());
        getNTV().setAllowTranscriptSelect(config.getAllowTranscriptSelect());
        getNTV().setAllowAnnotationSelect(config.getAllowAnnotationSelect());
        getNTV().setAllowMultiAgentSelect(config.getAllowMultiAgentSelect());
    }
    /**
     * Refresh the transcriptionView. This method does NOT change the settings of the view,
     * it merely clears the contents and redisplays the transcription segments and the annotation
     * elements. The view settings are changed in 
     * {@link project.ami.nxtutils.AbstractCallableTool#initTranscriptionViewSettings initTranscriptionViewSettings}.

     * May be overriden, but default behaviour is OK for most. Default: display all segments of type config.getSegmentationElementName()
     * and display all annotation element of all types in config.getDisplayedAnnotationNames().
     */
    public void refreshTranscriptionView() {
        Transform t = new Transform() { 
            public Object transform(Object o) { 
                return ((List)o).get(0); 
            } 
        }; 
        //display segments
        Iterator elemIt = search("($a " + config.getSegmentationElementName() + ")").iterator();
        if (elemIt.hasNext()){
            elemIt.next();
            Iterator transformedIt = new IteratorTransform(elemIt, t);     	
            getNTV().setDisplayedSegments(transformedIt);
        }  
        //display annotations on the transcription
        Iterator it = config.getDisplayedAnnotationNames().iterator();
        String elements = "";
        boolean first = true;
        while (it.hasNext()) {
            if (first) {
                first = false;
            } else {
                elements += "|";
            }
            elements += (String)it.next();
        }
        if (!elements.equals("")) {
            elemIt = search("($a " + elements +")").iterator();
            if (elemIt.hasNext()) {
                elemIt.next();  //first element is a list of some general search result variables
                Iterator transformedIt = new IteratorTransform(elemIt, t);     	
                getNTV().displayAnnotationElements(transformedIt);
            }
        }
    }

//=========================== LNF =============================================

    /** 
     * Initializes the look and feel to something more elegant. Others might disagree and override this method...
     */
    protected void initLnF() {

	System.out.println("Abstract callable init");
        JDialog.setDefaultLookAndFeelDecorated(true);
        JFrame.setDefaultLookAndFeelDecorated(true);
        Toolkit.getDefaultToolkit().setDynamicLayout(true);
        System.setProperty("sun.awt.noerasebackground","true");        
        try {
            PlasticLookAndFeel.setCurrentTheme(new DesertBlue());
            Options.setPopupDropShadowEnabled(true);
	    Options.setUseNarrowButtons(true);
	    Options.setUseSystemFonts(true);
            Options.setDefaultIconSize(new Dimension (16,16));
	    Plastic3DLookAndFeel olaLF = new Plastic3DLookAndFeel();
	    UIManager.setLookAndFeel(olaLF);
            //update(c);
        } catch (Exception ex) {
            Debug.print("Error in LookaNdFeelSupport!", Debug.ERROR);ex.printStackTrace();
        }
    }

//=========================== SEARCH =============================================


   /** 
    *Search engine to find annotation elements 
    */
    protected Engine searchEngine= new Engine();
    public List search(String query) {
        List result = null;
    	try {
    	    result = searchEngine.search(nom, query); 
    	} catch (Throwable e) {
    	    e.printStackTrace();
    	}
    	if (result == null || result.size() == 1) {
    	    Debug.print("NO DATA ELEMENTS IN CORPUS! ", Debug.ERROR);
    	}
    	return result;
    }
    public QueryHandler getQueryHandler() {
	return searchGui;
    }
    
//=========================== LOG =============================================
    
    /**
     * Loghandler. Probably no need to store...
     */
    protected MyLogHandler mlh = null;
    /**
     * Logframe. Stored to allow easy rearranging of interface windows in initialization of tool
     */
    protected JInternalFrame logFrame = null;
    /**
     * Initializes a logframe on the desktop that listens to the given logger
     * (desktop should be initialized) 
     *
     * Also initilizes the log used to figure out how well annotators are performing.
     * Only effect when config showLogWindows is true.
     */
    protected void setupLog(Logger logger, int x, int y, int w, int h) {
        if (!getConfig().showLogWindows()) {
            Debug.print("Logwindow turned off", Debug.DEBUG);
            logFrame = new JInternalFrame("Dummy logwindow. Should be invisible."); //to avoid nullpointerexceptions
            return;
        }
        mlh = new MyLogHandler();
        logger.addHandler(mlh);
        logFrame = mlh.createStatusFrame(getDesktop(),x,y,w,h);
        SwingUtils.getResourceIcon(logFrame, "/eclipseicons/elcl16/linkto_help.gif",getClass());
    }
    

//=========================== ACTIONS =============================================

    /**
     * Global actions: Each global action is stored in the global action map
     * {@link project.ami.nxtutils.AbstractCallableTool#actMap actMap}, under its (static) name.
     * The method {@link project.ami.nxtutils.AbstractCallableTool#initActions initActions}
     * creates and initializes these actions. NEVER access attrib directly.
     * getActionMap also initializes map if non-existent...
     * <p>
     * Example: the action to refresh the TranscriptionView is called REFRESH_NTV_ACTION. 
     * <p> Read the documetnation. Not every action is always defined, eg if you didn't create NTV, refreshntv doesn't exist.
     * <p>don't confuse with the actions maps used for application specific component specific behaviour.
     * this map is only the 'global' things. Help, search, file ops, etc
     */
    private ActionMap actMap;
    /**
     * See {@link project.ami.nxtutils.AbstractCallableTool#ntv ntv} attribute.
     */
    public ActionMap getActionMap() {
        if (actMap == null) {
            setupActions();
        }
        return actMap;
    }
    /**
     * Refresh action: refresh the NTranscriptionView.
     * See {@link project.ami.nxtutils.AbstractCallableTool#ntv ntv} attribute.
     * Doesn't exist if no NTV initialized when actmap was created!
     */
    public static final String REFRESH_NTV_ACTION = "Refresh transcription view";
    /**
     * Print action: print the NTranscriptionView.
     * See {@link project.ami.nxtutils.AbstractCallableTool#ntv ntv} attribute.
     * Doesn't exist if no NTV initialized when actmap was created!
     */
    public static final String PRINT_NTV_ACTION = "Print transcription view";
    /**
     * Exit action: Exit application. Check for saved changes!
     * Also causes the CVS commit/checkin, if usecvs true was specified at tool startup.
     */
    public static final String EXIT_ACTION = "Exit";
    /**
     * Save action: Save corpus.
     */
    public static final String SAVE_ACTION = "Save";
    /**
     * Show help.
     */
    public static final String HELP_ACTION = "OPEN HELP";
    /**
     * Show searchwindow.
     */
    public static final String SEARCH_ACTION = "SEARCH CURRENT CORPUS";
    /**
     * Override this method if your application has additional global actions...
     * it is advisable not to confuse this action map with e.g. editorpane-specific actions!
     * See {@link project.ami.nxtutils.AbstractCallableTool#ntv ntv} attribute.
     */
    protected void setupActions() {
        actMap = new ActionMap();
        Action act = null;
        NTranscriptionView ntv = getNTV();
        if (ntv != null) {
            //print action
            act = new AbstractAction("Print transcription area") {
                public void actionPerformed(ActionEvent ev) {
                    getNTV().printTextArea();
                }
            };
            if (getClass().getResource("/eclipseicons/etool16/print_edit.gif") != null) {
                Icon value = new ImageIcon(getClass().getResource("/eclipseicons/etool16/print_edit.gif"));
                act.putValue(Action.SMALL_ICON, value);
            }
            act.putValue(Action.SHORT_DESCRIPTION,"Print the text from the transcription area, including the annotation markup.");
            act.putValue(Action.MNEMONIC_KEY,new Integer(java.awt.event.KeyEvent.VK_P));
            act.putValue(Action.ACCELERATOR_KEY,KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_P, java.awt.event.InputEvent.CTRL_MASK ));
            actMap.put(PRINT_NTV_ACTION, act);

            //refresh action
            act = new AbstractAction("Refresh") {
                public void actionPerformed(ActionEvent ev) {
                    refreshTranscriptionView();
                }
            };
            if (getClass().getResource("/eclipseicons/clcl16/refresh.gif") != null) {
                Icon value = new ImageIcon(getClass().getResource("/eclipseicons/clcl16/refresh.gif"));
                act.putValue(Action.SMALL_ICON, value);
            }
            act.putValue(Action.SHORT_DESCRIPTION,"Refresh transcription view.");
            act.putValue(Action.ACCELERATOR_KEY,KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F5, 0 ));
            act.putValue(Action.MNEMONIC_KEY,new Integer(java.awt.event.KeyEvent.VK_R));
            actMap.put(REFRESH_NTV_ACTION, act);
        }
        
        //save action
        act = new AbstractAction("Save corpus") {
            public void actionPerformed(ActionEvent ev) {
                try {
                    getCorpus().getMetaData().writeMetaData(getCorpus().getMetaData().getFilename());
                    getCorpus().serializeCorpusChanged();
                    Logger.global.info("Corpus saved.");
                } catch (Exception e) {
                    e.printStackTrace();
                    Logger.global.info("FAILED to save corpus!! Check error messages.");
                }
            }
        };
        if (getClass().getResource("/eclipseicons/etool16/save_edit.gif") != null) {
            Icon value = new ImageIcon(getClass().getResource("/eclipseicons/etool16/save_edit.gif"));
            act.putValue(Action.SMALL_ICON, value);
        }
        act.putValue(Action.SHORT_DESCRIPTION,"Save the current corpus.");
        act.putValue(Action.MNEMONIC_KEY,new Integer(java.awt.event.KeyEvent.VK_S));
        act.putValue(Action.ACCELERATOR_KEY,KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK ));
        actMap.put(SAVE_ACTION, act);
        

        //exit action
        act = new AbstractAction("Exit") {
            public void actionPerformed(ActionEvent ev) {
                CheckSave co = new CheckSave(getCorpus()); 
                if (!(co.popupDialog()==JOptionPane.CANCEL_OPTION)) { 
                    if (useCVS()) {
                        writeCVS();
                    }
                    //no need to dispose anything?
                    if (getMediaPlayer() != null) getMediaPlayer().close();
                    System.exit(0);
                }
            }
        };
        if (getClass().getResource("/eclipseicons/elcl16/close_view.gif") != null) {
            Icon value = new ImageIcon(getClass().getResource("/eclipseicons/elcl16/close_view.gif"));
            act.putValue(Action.SMALL_ICON, value);
        }
        act.putValue(Action.SHORT_DESCRIPTION,"Exit application after checking whether the corpus needs to be saved.");
        act.putValue(Action.MNEMONIC_KEY,new Integer(java.awt.event.KeyEvent.VK_X));
        actMap.put(EXIT_ACTION, act);


        if (searchGui != null) {
            //Search action
            act = new AbstractAction("Search") {
                public void actionPerformed(ActionEvent ev) {
                    searchGui.popupSearchWindow();
                }
            };
            if (getClass().getResource("/eclipseicons/ctool16/search.gif") != null) {
                Icon value = new ImageIcon(getClass().getResource("/eclipseicons/ctool16/search.gif"));
                act.putValue(Action.SMALL_ICON, value);
            }
            act.putValue(Action.SHORT_DESCRIPTION,"Search the corpus.");
            act.putValue(Action.ACCELERATOR_KEY,KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F, java.awt.event.InputEvent.CTRL_MASK ));
            act.putValue(Action.MNEMONIC_KEY,new Integer(java.awt.event.KeyEvent.VK_S));
            actMap.put(SEARCH_ACTION, act);
        }

        try {
            //help set action!!!
            String helpHS = config.getHelpSetName();
            HelpSet hs = null;
            ClassLoader cl = getClass().getClassLoader();
            try {
                URL hsURL = HelpSet.findHelpSet(cl, helpHS);
                hs = new HelpSet(null, hsURL);
            } catch (Exception ee) {
                Debug.print( "HelpSet " + ee.getMessage(), Debug.DEBUG);
                Debug.print("HelpSet "+ helpHS +" not found", Debug.WARNING);
                return;
            }   
            HelpBroker hb = hs.createHelpBroker();
            final ActionListener al = new CSH.DisplayHelpFromSource( hb );
            //Help action
            act = new AbstractAction("Help") {
                public void actionPerformed(ActionEvent ev) {
                    al.actionPerformed(ev);
                }
            };
            if (getClass().getResource("/eclipseicons/elcl16/linkto_help.gif") != null) {
                Icon value = new ImageIcon(getClass().getResource("/eclipseicons/elcl16/linkto_help.gif"));
                act.putValue(Action.SMALL_ICON, value);
            }
            act.putValue(Action.SHORT_DESCRIPTION,"Show help pages.");
            act.putValue(Action.ACCELERATOR_KEY,KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F1, 0));
            act.putValue(Action.MNEMONIC_KEY,new Integer(java.awt.event.KeyEvent.VK_H));
            actMap.put(HELP_ACTION, act);
        } catch (Exception e) {
            Debug.print("Couldn't initialize help", Debug.WARNING);
        }

    }


//======================= SEARCH GUI =============================

    /**
     * The search window which is used, not internall, but externally for the user.
     */
    protected net.sourceforge.nite.search.GUI searchGui;
    /**
     * See {@linkplain #searchGui}
     */
    protected void setupSearch() {
        searchGui = new net.sourceforge.nite.search.GUI(nom);
        if (getNTV()!=null) {
            searchGui.registerResultHandler(getNTV()) ;
        }    
    }
    
//======================== MENUS ===================================
    private JMenuBar mainMenuBar; //any reason to store this?
    protected JMenuBar getMenuBar() {
        return mainMenuBar;
    }
    /**
     * A map of all menu's. Doing it like this means that after global init you can add your own options to any
     * menu.
     */
    private Map menuMap = new HashMap();
    protected Map getMenuMap() {
        return menuMap;
    }
    //private JMenu fileM;
    //private JMenu viewM;
    //private JMenu helpM;
    /**
     *  Menu bar setup. 
     EXPLAIN HOW TO EXTEND
     
     anyhow, this method should maybe be changed in such a way that it is also
     configurable which menu options exist....
     */
    protected void setupMenus(){
    	mainMenuBar = new JMenuBar();
    	getMainFrame().setJMenuBar(mainMenuBar);
        ActionMap amap = getActionMap(); // this also initializes if map not yet present
        JMenu fileM = new JMenu("File");
    	mainMenuBar.add(fileM);
    	menuMap.put("File",fileM);
        fileM.add(new JMenuItem(amap.get(SAVE_ACTION)));
        if (amap.get(PRINT_NTV_ACTION) != null) {
            fileM.add(new JMenuItem(amap.get(PRINT_NTV_ACTION)));
        }
        fileM.add(new JMenuItem(amap.get(EXIT_ACTION)));
        
        final Action exa = (Action)amap.get(EXIT_ACTION);
    	getMainFrame().addWindowListener(new WindowAdapter() {
    	    public void windowClosing(WindowEvent e) {
    	        exa.actionPerformed(null);
    	    }
    	});
        
        JMenu viewM = new JMenu("View");
    	menuMap.put("View",viewM);
    	mainMenuBar.add(viewM);
        if (amap.get(REFRESH_NTV_ACTION) != null) {
            viewM.add(new JMenuItem(amap.get(REFRESH_NTV_ACTION)));
        }
        if (amap.get(SEARCH_ACTION) != null) {
            viewM.add(new JMenuItem(amap.get(SEARCH_ACTION)));
        }
        JMenu helpM = new JMenu("Help");
    	menuMap.put("Help",helpM);
    	mainMenuBar.add(helpM);
        helpM.add(new JMenuItem(amap.get(HELP_ACTION)));
        
    }

    

}
